diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGCSupport.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGCSupport.java
index e0ce621..c97d9c9 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGCSupport.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGCSupport.java
@@ -24,32 +24,22 @@
 import static org.apache.jackrabbit.oak.plugins.document.util.Utils.getAllDocuments;
 import static org.apache.jackrabbit.oak.plugins.document.util.Utils.getSelectedDocuments;
 
-import javax.annotation.CheckForNull;
-import javax.annotation.Nullable;
-
 import java.io.Closeable;
-import java.lang.ref.Reference;
-import java.util.Calendar;
-import java.util.Iterator;
-import java.util.Locale;
 import java.util.Set;
 
-import java.util.concurrent.TimeUnit;
 import org.apache.jackrabbit.oak.commons.IOUtils;
 import org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType;
 import org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollector.VersionGCStats;
 import org.apache.jackrabbit.oak.plugins.document.util.Utils;
-
-import com.google.common.base.Predicate;
-import org.apache.jackrabbit.oak.plugins.document.util.CloseableIterable;
-import org.apache.jackrabbit.oak.plugins.document.util.Utils;
 import org.apache.jackrabbit.oak.stats.Clock;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import com.google.common.base.Predicate;
+
 public class VersionGCSupport {
 
-    private static final Logger Log = LoggerFactory.getLogger(VersionGCSupport.class);
+    private static final Logger LOG = LoggerFactory.getLogger(VersionGCSupport.class);
 
     private final DocumentStore store;
 
@@ -139,7 +129,7 @@ public long getOldestDeletedOnceTimestamp(Clock clock, long precisionMs) {
 
         while (duration > precisionMs) {
             // check for delete candidates in [ ts, ts + duration]
-            Log.debug("find oldest _deletedOnce, check < {}", Utils.timestampToString(ts + duration));
+            LOG.debug("find oldest _deletedOnce, check < {}", Utils.timestampToString(ts + duration));
             docs = getPossiblyDeletedDocs(ts, ts + duration);
             if (docs.iterator().hasNext()) {
                 // look if there are still nodes to be found in the lower half
@@ -150,11 +140,9 @@ public long getOldestDeletedOnceTimestamp(Clock clock, long precisionMs) {
                 ts = ts + duration;
                 duration /= 2;
             }
-            if (docs instanceof Closeable) {
-                IOUtils.closeQuietly((Closeable)docs);
-            }
+            Utils.closeIfCloseable(docs);
         }
-        Log.debug("find oldest _deletedOnce to be {}", Utils.timestampToString(ts));
+        LOG.debug("find oldest _deletedOnce to be {}", Utils.timestampToString(ts));
         return ts;
     }
 
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java
index f8dd0dc..adcf323 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/VersionGarbageCollector.java
@@ -50,6 +50,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.StandardSystemProperty.LINE_SEPARATOR;
 import static com.google.common.collect.Iterables.all;
@@ -205,7 +206,7 @@ public void setCollectLimit(long limit) {
     public void setMaxDuration(TimeUnit unit, long t) { this.maxDurationMs = unit.toMillis(t); }
 
     /**
-     * Set the maxiumum number of iterations that shall be attempted in a single run. A value
+     * Set the maximum number of iterations that shall be attempted in a single run. A value
      * of 0 means that there is no limit. Since the garbage collector uses iterations to find
      * suitable time intervals and set sizes for cleanups, limiting the iterations is only
      * recommended for setups where the collector is called often.
@@ -218,14 +219,16 @@ public void setCollectLimit(long limit) {
      * Set a delay factor between batched database modifications. This rate limits the writes
      * to the database by a garbage collector. 0, e.g. no delay, is the default. This is recommended
      * when garbage collection is done during a maintenance time when other system load is low.
-     *
+     * <p>
      * For factory > 0, the actual delay is the duration of the last batch modification times
      * the factor. Example: 0.25 would result in a 25% delay, e.g. a batch modification running
      * 10 seconds would be followed by a sleep of 2.5 seconds.
      *
      * @param f the factor used to calculate batch modification delays
      */
-    public void setModifyBatchDelayFactor(double f) { this.modifyBatchDelayFactor = f; }
+    public void setModifyBatchDelayFactor(double f) {
+        this.modifyBatchDelayFactor = f;
+    }
 
     public VersionGCInfo getInfo(long maxRevisionAge, TimeUnit unit) throws IOException {
         long maxRevisionAgeInMillis = unit.toMillis(maxRevisionAge);
@@ -812,8 +815,7 @@ private int removeDeletedDocuments(Iterator<String> docIdsToDelete,
                         String msg = String.format("Deleted %d (%1.2f%%) documents so far", deletedCount, progress);
                         log.info(msg);
                     }
-                }
-                finally {
+                } finally {
                     delayOnModifications(timer.stop().elapsed(TimeUnit.MILLISECONDS));
                 }
             }
@@ -940,7 +942,7 @@ public boolean apply(@Nullable Range input) {
 
         /**
          * Gives a recommendation about parameters for the next revision garbage collection run.
-         *
+         * <p>
          * With the given maximum age of revisions to keep (earliest time in the past to collect),
          * the desired precision in which times shall be sliced and the given limit on the number
          * of collected documents in one run, calculate <ol>
@@ -951,7 +953,7 @@ public boolean apply(@Nullable Range input) {
          * </ol>
          * After a run, recommendations evaluate the result of the gc to update its persisted recommendations
          * for future runs.
-         *
+         * <p>
          * In the settings collection, recommendations keeps "revisionsOlderThan" from the last successful run.
          * It also updates the time interval recommended for the next run.
          *
@@ -971,8 +973,7 @@ public boolean apply(@Nullable Range input) {
                 log.debug("No lastOldestTimestamp found, querying for the oldest deletedOnce candidate");
                 oldestPossible = versionStore.getOldestDeletedOnceTimestamp(nodeStore.getClock(), precisionMs) - 1;
                 log.debug("lastOldestTimestamp found: {}", Utils.timestampToString(oldestPossible));
-            }
-            else {
+            } else {
                 oldestPossible = lastOldestTimestamp - 1;
             }
 
@@ -987,8 +988,7 @@ public boolean apply(@Nullable Range input) {
                     log.debug("previous runs recommend a {} sec duration, scope now {}",
                             TimeUnit.MILLISECONDS.toSeconds(suggestedIntervalMs), scope);
                 }
-            }
-            else {
+            } else {
                 /* Need to guess. Count the overall number of _deletedOnce documents. If those
                  * are more than we want to collect in a single run, reduce the time scope so
                  * that we likely see a fitting fraction of those documents.
@@ -1018,8 +1018,7 @@ public boolean apply(@Nullable Range input) {
                     log.warn("Ignoring RGC run because a valid checkpoint [{}] exists inside minimal scope {}.",
                             checkpoint.toReadableString(), minimalScope);
                     ignoreDueToCheckPoint = true;
-                }
-                else {
+                } else {
                     scope = scope.notLaterThan(checkpoint.getTimestamp() - 1);
                     log.debug("checkpoint at [{}] found, scope now {}",
                             Utils.timestampToString(checkpoint.getTimestamp()), scope);
@@ -1057,15 +1056,13 @@ public void evaluate(VersionGCStats stats) {
                         this.maxCollect, TimeUnit.MILLISECONDS.toSeconds(nextDuration));
                 setLongSetting(SETTINGS_COLLECTION_REC_INTERVAL_PROP, nextDuration);
                 stats.needRepeat = true;
-            }
-            else if (!stats.canceled && !stats.ignoredGCDueToCheckPoint) {
+            } else if (!stats.canceled && !stats.ignoredGCDueToCheckPoint) {
                 // success, we would not expect to encounter revisions older than this in the future
                 setLongSetting(SETTINGS_COLLECTION_OLDEST_TIMESTAMP_PROP, scope.toMs);
 
                 if (maxCollect <= 0) {
                     log.debug("successful run without effective limit, keeping recommendations");
-                }
-                else if (scope.getDurationMs() == suggestedIntervalMs) {
+                } else if (scope.getDurationMs() == suggestedIntervalMs) {
                     int count = stats.deletedDocGCCount - stats.deletedLeafDocGCCount;
                     double used = count / (double) maxCollect;
                     if (used < 0.66) {
@@ -1074,8 +1071,7 @@ else if (scope.getDurationMs() == suggestedIntervalMs) {
                                 Math.round(used*1000)/10.0, TimeUnit.MILLISECONDS.toSeconds(nextDuration));
                         setLongSetting(SETTINGS_COLLECTION_REC_INTERVAL_PROP, nextDuration);
                     }
-                }
-                else {
+                } else {
                     log.debug("successful run not following recommendations, keeping them");
                 }
                 stats.needRepeat = !scopeIsComplete;
@@ -1106,7 +1102,7 @@ private void setLongSetting(String propName, long val) {
         public final long toMs;
 
         public TimeInterval(long fromMs, long toMs) {
-            assert(fromMs <= toMs);
+            checkArgument(fromMs < toMs);
             this.fromMs = fromMs;
             this.toMs = toMs;
         }
diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoVersionGCSupport.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoVersionGCSupport.java
index 050e60d..0a4d515 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoVersionGCSupport.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/mongo/MongoVersionGCSupport.java
@@ -20,7 +20,6 @@
 package org.apache.jackrabbit.oak.plugins.document.mongo;
 
 import com.mongodb.client.model.DBCollectionCountOptions;
-import com.mongodb.client.model.DBCollectionFindOptions;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
@@ -37,7 +36,6 @@
 import com.mongodb.QueryBuilder;
 import com.mongodb.ReadPreference;
 import java.util.concurrent.TimeUnit;
-import org.apache.jackrabbit.oak.commons.IOUtils;
 import org.apache.jackrabbit.oak.plugins.document.Document;
 import org.apache.jackrabbit.oak.plugins.document.NodeDocument;
 import org.apache.jackrabbit.oak.plugins.document.SplitDocumentCleanUp;
@@ -125,7 +123,7 @@ public long getOldestDeletedOnceTimestamp(Clock clock, long precisionMs) {
         LOG.debug("getOldestDeletedOnceTimestamp() <- start");
         DBObject query = start(NodeDocument.DELETED_ONCE).is(Boolean.TRUE).get();
         DBCursor cursor = getNodeCollection().find(query).sort(start(NodeDocument.MODIFIED_IN_SECS).is(1).get()).limit(1);
-        CloseableIterable results = CloseableIterable.wrap(transform(cursor, new Function<DBObject, NodeDocument>() {
+        CloseableIterable<NodeDocument> results = CloseableIterable.wrap(transform(cursor, new Function<DBObject, NodeDocument>() {
             @Override
             public NodeDocument apply(DBObject input) {
                 return store.convertFromDBObject(NODES, input);
@@ -143,7 +141,7 @@ public NodeDocument apply(DBObject input) {
             }
         }
         finally {
-            IOUtils.closeQuietly(results);
+            Utils.closeIfCloseable(results);
         }
         LOG.debug("getOldestDeletedOnceTimestamp() -> none found, return current time");
         return clock.getTime();
diff --git a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/VersionGCDeletionTest.java b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/VersionGCDeletionTest.java
index f5f04e6..b292336 100644
--- a/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/VersionGCDeletionTest.java
+++ b/oak-core/src/test/java/org/apache/jackrabbit/oak/plugins/document/VersionGCDeletionTest.java
@@ -32,7 +32,6 @@
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
-import java.util.Locale;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Future;
@@ -476,7 +475,7 @@ public void deleteLimitChunks() throws Exception{
         for (int i = 0; i < noOfChunks; ++i) {
             NodeBuilder b1 = store.getRoot().builder();
             NodeBuilder xb = b1.child("x"+i);
-            for (int j = 0; j < noOfDocsInChunk; ++j){
+            for (int j = 0; j < noOfDocsInChunk; ++j) {
                 xb.child("a"+j).child("b"+j);
             }
             store.merge(b1, EmptyHook.INSTANCE, CommitInfo.EMPTY);
@@ -484,7 +483,6 @@ public void deleteLimitChunks() throws Exception{
         }
 
         long maxAge = 2; //hours
-        long delta = TimeUnit.MINUTES.toMillis(10);
 
         for (int i = 0; i < noOfChunks; ++i) {
             NodeBuilder b2 = store.getRoot().builder();
@@ -527,7 +525,6 @@ public void deleteLimitChunks() throws Exception{
     public void deleteChunksInIterations() throws Exception{
         int noOfDocsInChunk = 100;
         int noOfChunks = 10;
-        DocumentStore ts = new MemoryDocumentStore();
         store = new DocumentMK.Builder()
                 .clock(clock)
                 .setDocumentStore(new MemoryDocumentStore())
@@ -549,7 +546,6 @@ public void deleteChunksInIterations() throws Exception{
         }
 
         long maxAge = 2; //hours
-        long delta = TimeUnit.MINUTES.toMillis(10);
 
         for (int i = 0; i < noOfChunks; ++i) {
             NodeBuilder b2 = store.getRoot().builder();
